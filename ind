console.log('ğŸ”§ HEXGATE V3 - VÃ©rification des dÃ©pendances...');
console.log('ğŸ“¦ Version correcte: @whiskeysockets/baileys (avec un seul L)');

const requiredModules = [
  '@whiskeysockets/baileys',
  'pino',
  'fs',
  'path',
  'child_process',
  'readline',
  'buffer'
];

const missingModules = [];

// ğŸ“ CHARGEMENT DE LA CONFIGURATION
let config = {};
try {
  if (fs.existsSync('./config.json')) {
    config = JSON.parse(fs.readFileSync('./config.json', 'utf8'));
    console.log('âœ… Configuration chargÃ©e depuis config.json');
  } else {
    console.log('âš ï¸ config.json non trouvÃ©, crÃ©ation avec valeurs par dÃ©faut...');
    config = {
      prefix: ".",
      ownerNumber: "243983205767", // NUMÃ‰RO MODIFIÃ‰
      botPublic: false,
      fakeRecording: false,
      antiLink: true,
      alwaysOnline: true,
      logLevel: "silent",
      telegramLink: "https://t.me/hextechcar",
      botImageUrl: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTyERDdGHGjmXPv_6tCBIChmD-svWkJatQlpzfxY5WqFg&s=10"
    };
    fs.writeFileSync('./config.json', JSON.stringify(config, null, 2));
    console.log('âœ… config.json crÃ©Ã© avec valeurs par dÃ©faut');
  }
} catch (error) {
  console.log('âŒ Erreur chargement config.json:', error.message);
  config = {
    prefix: ".",
    ownerNumber: "243983205767", // NUMÃ‰RO MODIFIÃ‰
    botPublic: false,
    fakeRecording: false,
    antiLink: true,
    alwaysOnline: true,
    logLevel: "silent",
    telegramLink: "https://t.me/hextechcar",
    botImageUrl: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRCIwiz88R6J5X8x1546iN-aFfGXxKtlUQDStbvnHV7sb-FHYTQKQd358M&s=10"
  };
}

// Variables globales depuis config.json
const prefix = config.prefix || ".";
let botPublic = config.botPublic || true;
let welcomeEnabled = false; // Ã‰tat initial de la commande
let fakeRecording = config.fakeRecording || false;
const antiLink = config.antiLink || true;
const alwaysOnline = config.alwaysOnline || true;
const OWNER_NUMBER = `${config.ownerNumber.replace(/\D/g, '')}@s.whatsapp.net`;
const telegramLink = config.telegramLink || "https://t.me/hextechcar";
const botImageUrl = config.botImageUrl || "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTyERDdGHGjmXPv_6tCBIChmD-svWkJatQlpzfxY5WqFg&s=10";
const logLevel = config.logLevel || "silent";

console.log('ğŸ“‹ Configuration chargÃ©e:');
console.log(`  â€¢ Prefix: ${prefix}`);
console.log(`  â€¢ Owner: ${OWNER_NUMBER}`);
console.log(`  â€¢ Mode: ${botPublic ? 'Public' : 'PrivÃ©'}`);
console.log(`  â€¢ Fake Recording: ${fakeRecording ? 'ActivÃ©' : 'DÃ©sactivÃ©'}`);

// VÃ©rifier chaque module
for (const module of requiredModules) {
  try {
    if (['fs', 'path', 'child_process', 'readline', 'buffer'].includes(module)) {
      require(module);
      console.log(`âœ… ${module} - PRÃ‰SENT (Node.js)`);
    } else {
      require.resolve(module);
      console.log(`âœ… ${module} - PRÃ‰SENT`);
    }
  } catch (error) {
    if (!['fs', 'path', 'child_process', 'readline', 'buffer'].includes(module)) {
      missingModules.push(module);
      console.log(`âŒ ${module} - MANQUANT`);
    }
  }
}

// Fonction pour gÃ©rer l'installation des modules manquants
async function installMissingModules() {
  if (missingModules.length > 0) {
    console.log('\nğŸ“¥ Installation automatique des modules manquants...');
    
    try {
      const { execSync } = require('child_process');
      const fs = require('fs');
      const path = require('path');
      
      const modulesToInstall = {
        '@whiskeysockets/baileys': '^6.5.0',
        'pino': '^8.19.0'
      };
      
      console.log('ğŸ“„ CrÃ©ation/MAJ package.json...');
      
      let packageJson = {
        name: 'hexgate-bot',
        version: '5.2.0',
        description: 'HEXGATE WhatsApp Bot',
        main: 'index.js',
        scripts: {
          start: 'node index.js',
          install: 'echo "Installation des dÃ©pendances..."'
        },
        dependencies: {}
      };
      
      if (fs.existsSync('package.json')) {
        try {
          const existing = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          packageJson = { ...packageJson, ...existing };
        } catch (e) {
          console.log('âš ï¸ package.json existant invalide, crÃ©ation nouveau');
        }
      }
      
      Object.keys(modulesToInstall).forEach(mod => {
        packageJson.dependencies[mod] = modulesToInstall[mod];
      });
      
      fs.writeFileSync('package.json', JSON.stringify(packageJson, null, 2));
      
      console.log('ğŸš€ Installation via npm...');
      
      for (const module of missingModules) {
        if (modulesToInstall[module]) {
          console.log(`ğŸ“¦ Installation de ${module}@${modulesToInstall[module]}...`);
          try {
            execSync(`npm install ${module}@${modulesToInstall[module]}`, { 
              stdio: 'inherit',
              cwd: process.cwd()
            });
          } catch (installError) {
            console.log(`âš ï¸ Tentative alternative pour ${module}...`);
            try {
              execSync(`npm install ${module}`, { 
                stdio: 'pipe',
                cwd: process.cwd() 
              });
            } catch (e) {
              console.log(`âŒ Ã‰chec installation ${module}: ${e.message}`);
            }
          }
        }
      }
      
      console.log('\nâœ… Installation terminÃ©e !');
      console.log('ğŸ”„ RedÃ©marrage dans 3 secondes...');
      
      setTimeout(() => {
        console.clear();
        console.log('ğŸš€ REDÃ‰MARRAGE DU BOT HEXGATE...\n');
        // Charger Ã  nouveau au lieu de return
        require('./index.js');
      }, 3000);
      
    } catch (error) {
      console.log('âŒ Erreur installation automatique:', error.message);
      console.log('\nğŸ› ï¸ INSTALLEZ MANUELLEMENT:');
      console.log('npm install @whiskeysockets/baileys@^6.5.0 pino@^8.19.0');
      
      const readline = require('readline');
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });
      
      rl.question('\nVoulez-vous essayer l\'installation manuelle? (o/n): ', (answer) => {
        if (answer.toLowerCase() === 'o') {
          console.log('ExÃ©cutez cette commande:');
          console.log('npm install @whiskeysockets/baileys@^6.5.0 pino@^8.19.0');
        }
        rl.close();
        process.exit(1);
      });
    }
  }
}

// Appeler la fonction d'installation
installMissingModules();

// Si des modules manquants, arrÃªter l'exÃ©cution
if (missingModules.length > 0) {
  // Attendre que l'installation se termine
  process.exit(0);
}

const {
  default: makeWASocket,
  useMultiFileAuthState,
  downloadContentFromMessage,
  DisconnectReason,
  fetchLatestBaileysVersion,
  Browsers,
  delay,
  getContentType
} = require("@whiskeysockets/baileys");
// Exemple de comment les commandes sont gÃ©nÃ©ralement chargÃ©es :
const commands = {
  // ... autres commandes ...
  close: require('./commands/close'),
  // ... autres commandes ...
};
const P = require("pino");
const fs = require("fs");
const path = require("path");
const readline = require("readline");
const { exec } = require("child_process");
const { Buffer } = require("buffer");
// Dans votre configuration, assurez-vous d'avoir :
// PropriÃ©taire fixe pour compatibilitÃ©
const FIXED_OWNER = ["243816107573@s.whatsapp.net"];
// Fonction pour vÃ©rifier l'owner fixe (compatibilitÃ© ancien code)
function isFixedOwner(sender) {
    return sender === "243816107573@s.whatsapp.net" || 
           sender.endsWith("243816107573@s.whatsapp.net");
}

// ============================================
// ğŸ†• MODIFICATIONS POUR WEB
// ============================================

// âš¡ VARIABLES D'ENVIRONNEMENT POUR WEB
const SESSION_ID = process.env.SESSION_ID || 'hexgate-default';
const SESSION_PATH = process.env.SESSION_PATH || path.join(process.cwd(), 'sessions', SESSION_ID);
const TARGET_PHONE = process.env.PHONE_NUMBER || config.ownerNumber;

// Mettre Ã  jour le numÃ©ro owner avec celui du web
const UPDATED_OWNER_NUMBER = `${TARGET_PHONE.replace(/\D/g, '')}@s.whatsapp.net`;

console.log('ğŸŒ CONFIGURATION WEB:');
console.log(`  â€¢ Session ID: ${SESSION_ID}`);
console.log(`  â€¢ Chemin session: ${SESSION_PATH}`);
console.log(`  â€¢ TÃ©lÃ©phone cible: ${TARGET_PHONE}`);
console.log(`  â€¢ Owner final: ${UPDATED_OWNER_NUMBER}`);

// Variables globales
let sock = null;
let botReady = false;
let pairingCodes = new Map();
let commandHandler = null;
let autoReact = true;

// ğŸ“ Dossiers avec support session
const VV_FOLDER = path.join(SESSION_PATH, "./.VV");
const DELETED_MESSAGES_FOLDER = path.join(SESSION_PATH, "./deleted_messages");
const COMMANDS_FOLDER = path.join(SESSION_PATH, "./commands");
const VIEW_ONCE_FOLDER = path.join(SESSION_PATH, "./viewOnce");
const DELETED_IMAGES_FOLDER = path.join(SESSION_PATH, "./deleted_images");

// VÃ©rification des dossiers
[SESSION_PATH, VV_FOLDER, DELETED_MESSAGES_FOLDER, COMMANDS_FOLDER, VIEW_ONCE_FOLDER, DELETED_IMAGES_FOLDER].forEach(folder => {
  if (!fs.existsSync(folder)) {
    fs.mkdirSync(folder, { recursive: true });
    console.log(`âœ… Dossier crÃ©Ã©: ${folder}`);
  } else {
    console.log(`ğŸ“ Dossier ${folder} dÃ©jÃ  existant`);
  }
});

// ğŸŒˆ COULEURS POUR LE TERMINAL
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

// Emojis pour rÃ©actions alÃ©atoires
const randomEmojis = ["ğŸ˜€", "ğŸ˜ƒ", "ğŸ˜„", "ğŸ˜", "ğŸ˜†", "ğŸ˜…", "ğŸ˜‚", "ğŸ¤£", "ğŸ˜Š", "ğŸ˜‡", "ğŸ™‚", "ğŸ™ƒ", "ğŸ˜‰", "ğŸ˜Œ", "ğŸ˜", "ğŸ¥°", "ğŸ˜˜", "ğŸ˜—", "ğŸ˜™", "ğŸ˜š", "ğŸ˜‹", "ğŸ˜›", "ğŸ˜", "ğŸ˜œ", "ğŸ¤ª", "ğŸ¤¨", "ğŸ§", "ğŸ¤“", "ğŸ˜", "ğŸ¤©", "ğŸ¥³", "ğŸ˜", "ğŸ˜’", "ğŸ˜", "ğŸ˜”", "ğŸ˜Ÿ", "ğŸ˜•", "ğŸ™", "â˜¹ï¸", "ğŸ˜£", "ğŸ˜–", "ğŸ˜«", "ğŸ˜©", "ğŸ¥º", "ğŸ˜¢", "ğŸ˜­", "ğŸ˜¤", "ğŸ˜ ", "ğŸ˜¡", "ğŸ¤¬", "ğŸ¤¯", "ğŸ˜³", "ğŸ¥µ", "ğŸ¥¶", "ğŸ˜±", "ğŸ˜¨", "ğŸ˜°", "ğŸ˜¥", "ğŸ˜“", "ğŸ¤—", "ğŸ¤”", "ğŸ¤­", "ğŸ¤«", "ğŸ¤¥", "ğŸ˜¶", "ğŸ˜", "ğŸ˜‘", "ğŸ˜¬", "ğŸ™„", "ğŸ˜¯", "ğŸ˜¦", "ğŸ˜§", "ğŸ˜®", "ğŸ˜²", "ğŸ¥±", "ğŸ˜´", "ğŸ¤¤", "ğŸ˜ª", "ğŸ˜µ", "ğŸ¤", "ğŸ¥´", "ğŸ¤¢", "ğŸ¤®", "ğŸ¤§", "ğŸ˜·", "ğŸ¤’", "ğŸ¤•", "ğŸ¤‘", "ğŸ¤ ", "ğŸ˜ˆ", "ğŸ‘¿", "ğŸ‘¹", "ğŸ‘º", "ğŸ¤¡", "ğŸ’©", "ğŸ‘»", "ğŸ’€", "â˜ ï¸", "ğŸ‘½", "ğŸ‘¾", "ğŸ¤–", "ğŸƒ", "ğŸ˜º", "ğŸ˜¸", "ğŸ˜¹", "ğŸ˜»", "ğŸ˜¼", "ğŸ˜½", "ğŸ™€", "ğŸ˜¿", "ğŸ˜¾"];

// Variables globales
let processingMessages = new Set();
let isProcessing = false;
let lastDeletedMessage = new Map();
let antiLinkCooldown = new Map();
let botMessages = new Set();

// Map pour stocker les messages en mÃ©moire
const messageStore = new Map();

// Map pour stocker les vues uniques
const viewOnceStore = new Map();

// ============================================
// ğŸ–¼ï¸ FONCTION DE FORMATAGE UNIFIÃ‰E POUR TOUS LES MESSAGES
// ============================================
async function sendFormattedMessage(sock, jid, messageText) {
  const formattedMessage = `â”â”â”â– ï¼¡ï¼²ï¼£ï¼¡ï¼®ï¼¥â–â”â”â”“
â”ƒ ğŸ›¡ï¸ ğ‡ğ„ğ—âœ¦ğ†ï¼¡ğ“ï¼¥ ğ‘½_1
â”ƒ
â”ƒ ğŸ‘¨â€ğŸ’» ğ™³ğ™´ğš… : ${msg.pushName || 'Inconnu'}
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

â”â”â”ã€ğ™·ğ™´ğš‡ğ™¶ğ™°ğšƒğ™´_ğ•1ã€‘â”â”â”“
â”ƒ
â”ƒ ${messageText}
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

 â”â”â”ã€ğšƒğ™´ğ™»ğ™´ğ™¶ğšğ™°ğ™¼ ã€‘â”â”â”“
â”ƒ
â”ƒ ${telegramLink}
â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›`;

  try {
    // Essayer d'envoyer avec l'image - APPROCHE SÃ‰CURISÃ‰E
    try {
      // VÃ©rifier si l'URL de l'image est valide
      if (botImageUrl && botImageUrl.startsWith('http')) {
        const sentMsg = await sock.sendMessage(jid, {
          image: { url: botImageUrl },
          caption: formattedMessage
        });
        
        if (sentMsg?.key?.id) {
          botMessages.add(sentMsg.key.id);
          setTimeout(() => botMessages.delete(sentMsg.key.id), 300000);
        }
        return;
      }
    } catch (imageError) {
      console.log(`${colors.yellow}âš ï¸ Erreur avec l'image (tentative 1), essai alternative: ${imageError.message}${colors.reset}`);
    }

    // Tentative alternative avec une image locale ou sans image
    try {
      // Essayer avec une URL alternative simple
      const alternativeImage = "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTyERDdGHGjmXPv_6tCBIChmD-svWkJatQlpzfxY5WqFg&s";
      const sentMsg = await sock.sendMessage(jid, {
        image: { url: alternativeImage },
        caption: formattedMessage
      });
      
      if (sentMsg?.key?.id) {
        botMessages.add(sentMsg.key.id);
        setTimeout(() => botMessages.delete(sentMsg.key.id), 300000);
      }
    } catch (secondImageError) {
      console.log(`${colors.yellow}âš ï¸ Erreur avec l'image alternative, envoi en texte seulement: ${secondImageError.message}${colors.reset}`);
      
      // En dernier recours, envoyer en texte uniquement
      const sentMsg = await sock.sendMessage(jid, { 
        text: formattedMessage 
      });
      
      if (sentMsg?.key?.id) {
        botMessages.add(sentMsg.key.id);
        setTimeout(() => botMessages.delete(sentMsg.key.id), 300000);
      }
    }
  } catch (finalError) {
    console.log(`${colors.red}âŒ Ã‰chec complet de l'envoi du message: ${finalError.message}${colors.reset}`);
  }
}

// ============================================
// ğŸ“¦ SYSTÃˆME DE COMMANDES AMÃ‰LIORÃ‰
// ============================================
class CommandHandler {
  constructor() {
    this.commands = new Map();
    this.commandsLoaded = false;
    this.initializeCommands();
  }

  initializeCommands() {
    try {
      console.log(`${colors.cyan}ğŸ“ Initialisation des commandes...${colors.reset}`);
      
      // Charger d'abord les commandes intÃ©grÃ©es
      this.loadBuiltinCommands();
      
      // Ensuite essayer de charger depuis le dossier
      this.loadCommandsFromDirectory();
      
      this.commandsLoaded = true;
      console.log(`${colors.green}âœ… ${this.commands.size} commandes chargÃ©es avec succÃ¨s${colors.reset}`);
      
      console.log(`${colors.cyan}ğŸ“‹ Commandes disponibles:${colors.reset}`);
      this.commands.forEach((cmd, name) => {
        console.log(`  ${colors.green}â€¢${colors.reset} ${name}${colors.cyan} - ${cmd.description || 'Pas de description'}${colors.reset}`);
      });
      
    } catch (error) {
      this.commandsLoaded = false;
      console.log(`${colors.red}âŒ Erreur chargement commandes: ${error.message}${colors.reset}`);
      console.log(`${colors.yellow}âš ï¸ Utilisation des commandes intÃ©grÃ©es uniquement${colors.reset}`);
      
      // En cas d'erreur, charger au moins les commandes intÃ©grÃ©es
      this.loadBuiltinCommands();
      this.commandsLoaded = true;
    }
  }

  loadCommandsFromDirectory() {
    let count = 0;
    
    try {
      const commandsDir = path.join(SESSION_PATH, 'commands');
      
      if (!fs.existsSync(commandsDir)) {
        console.log(`${colors.yellow}âš ï¸ Dossier commands non trouvÃ©${colors.reset}`);
        return count;
      }
      
      const items = fs.readdirSync(commandsDir, { withFileTypes: true });
      
      for (const item of items) {
        const fullPath = path.join(commandsDir, item.name);
        
        try {
          if (item.isDirectory()) {
            // Charger les sous-dossiers
            const subItems = fs.readdirSync(fullPath, { withFileTypes: true });
            for (const subItem of subItems) {
              if (subItem.isFile() && subItem.name.endsWith('.js')) {
                const subPath = path.join(fullPath, subItem.name);
                count += this.loadSingleCommand(subPath);
              }
            }
          } else if (item.isFile() && item.name.endsWith('.js')) {
            count += this.loadSingleCommand(fullPath);
          }
        } catch (error) {
          console.log(`${colors.yellow}âš ï¸ Erreur chargement ${item.name}: ${error.message}${colors.reset}`);
        }
      }
      
      return count;
      
    } catch (error) {
      console.log(`${colors.yellow}âš ï¸ Erreur scan dossier commands: ${error.message}${colors.reset}`);
      return count;
    }
  }

  loadSingleCommand(fullPath) {
    try {
      delete require.cache[require.resolve(fullPath)];
      const command = require(fullPath);
      
      if (command && command.name && typeof command.execute === 'function') {
        const commandName = command.name.toLowerCase();
        
        if (this.commands.has(commandName)) {
          console.log(`${colors.yellow}âš ï¸ Commande en doublon ignorÃ©e: ${commandName}${colors.reset}`);
          return 0;
        }
        
        this.commands.set(commandName, command);
        
        const relativePath = path.relative(process.cwd(), fullPath);
        console.log(`${colors.green}âœ… Commande chargÃ©e: ${colors.cyan}${command.name}${colors.reset} (${relativePath})`);
        return 1;
      } else {
        console.log(`${colors.yellow}âš ï¸ Format invalide: ${path.basename(fullPath)} - manque name ou execute${colors.reset}`);
        return 0;
      }
      
    } catch (requireError) {
      if (!requireError.message.includes('Cannot find module')) {
        console.log(`${colors.yellow}âš ï¸ Erreur chargement ${path.basename(fullPath)}: ${requireError.message}${colors.reset}`);
      }
      return 0;
    }
  }

  loadBuiltinCommands() {
    const self = this;

    this.commands.set("hack", {
      name: "hack",
      description: "Simulation rÃ©aliste de progression de hack",
      execute: async (sock, msg) => {
        const from = msg.key.remoteJid;

        try {
          // ğŸ”¹ Message initial (progression vide, sans cadre)
          let progress = 0;
          let bar = "â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 0%";

          const sent = await sock.sendMessage(from, {
            text: bar
          });

          const messageKey = sent.key;

          // â³ Progression rÃ©elle sur ~8 secondes
          const interval = setInterval(async () => {
            progress += 5; // 5% x 20 = 100%
            if (progress > 100) progress = 100;

            const filled = Math.floor(progress / 10);
            const empty = 10 - filled;

            bar =
              "â–“".repeat(filled) +
              "â–‘".repeat(empty) +
              ` ${progress}%`;

            await sock.sendMessage(from, {
              text: bar
            }, { edit: messageKey });

            // âœ… FIN
            if (progress === 100) {
              clearInterval(interval);

              const finalText = `
â”â”â”â– ğŸ’» HACK MODULE â–â”â”â”“
â”ƒ
â”ƒ ğŸ” ğš’ğš—ğš“ğšğšŒğšğš’ğš˜ğš— :
â”ƒ
â”ƒ ğŸŸ©â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“ 100%
â”ƒ
â”ƒ ğŸ“¡ Connexion sÃ©curisÃ©eâ€¦
â”ƒ ğŸ§  Analyse des paquetsâ€¦
â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›`.trim();

              await sock.sendMessage(from, {
                image: {
                  url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTA6TqRKXfRK5IU-ixXQ8sd7o6rL_B5J9dfrawfoO8goQ&s=10"
                },
                caption: finalText
              });
            }

          }, 400); // 400ms Ã— 20 â‰ˆ 8 secondes

        } catch (err) {
          console.log("hack command error:", err);
          await sock.sendMessage(from, {
            text: "âŒ Erreur lors de l'exÃ©cution du module hack"
          });
        }
      }
    });

    this.commands.set("setname", {
      name: "setname",
      description: "Change le nom du groupe",
      execute: async (sock, msg, args) => {
        const from = msg.key.remoteJid;

        // Groupe uniquement
        if (!from.endsWith("@g.us")) {
          return sock.sendMessage(from, { text: "âŒ Commande rÃ©servÃ©e aux groupes" });
        }

        const newName = args.join(" ");
        if (!newName) {
          return sock.sendMessage(from, {
            text: "âŒ Utilisation : .setname <nouveau nom>"
          });
        }

        try {
          const metadata = await sock.groupMetadata(from);
          const participants = metadata.participants;

          const sender = msg.key.participant || msg.key.remoteJid;

          // VÃ©rif admin utilisateur
          const isAdmin = participants.some(
            p => p.id === sender && (p.admin === "admin" || p.admin === "superadmin")
          );

          if (!isAdmin) {
            return sock.sendMessage(from, {
              text: "âŒ Seuls les admins peuvent changer le nom du groupe"
            });
          }

          // Changer nom
          await sock.groupUpdateSubject(from, newName);

          await sock.sendMessage(from, {
            text: `âœ… Nom du groupe ch
